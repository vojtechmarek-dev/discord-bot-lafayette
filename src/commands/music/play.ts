// src/commands/music/play.ts
import { SlashCommandBuilder, ChatInputCommandInteraction, GuildMember, EmbedBuilder, ChannelType, VoiceBasedChannel } from 'discord.js';
import { QueryResolver, QueryType, useMainPlayer } from 'discord-player'; // Import from discord-player
import { Command, ExtendedClient, PlayerQueueMetadata } from '../../types'; // Use your PlayerQueueMetadata if defined

async function prePlayValidation(
    interaction: ChatInputCommandInteraction
): Promise<{ member: GuildMember; voiceChannel: VoiceBasedChannel; player: ReturnType<typeof useMainPlayer> } | null> {
    if (!interaction.guildId) {
        await interaction.reply({ content: 'This command can only be used in a server.', ephemeral: true });
        return null;
    }

    const member = interaction.member as GuildMember; // Already in a guild, so member should exist
    if (!member) { // Should technically not happen if guildId is present and it's a guild command
        await interaction.reply({ content: 'Could not identify you as a member of this server.', ephemeral: true });
        return null;
    }

    const voiceChannel = member.voice.channel;
    if (!voiceChannel) {
        await interaction.reply({ content: 'You need to be in a voice channel to play music!', ephemeral: true });
        return null;
    }

    if (voiceChannel.type !== ChannelType.GuildVoice && voiceChannel.type !== ChannelType.GuildStageVoice) {
        await interaction.reply({ content: 'I can only join server voice or stage channels!', ephemeral: true });
        return null;
    }

    const player = useMainPlayer();
    if (!player) {
        await interaction.reply({ content: 'Music player is not available at the moment. Please try again later.', ephemeral: true });
        return null;
    }

    return { member, voiceChannel, player };
}

export const playCommand: Command = {
  data: new SlashCommandBuilder()
    .setName('play')
    .setDescription('P≈ôehraje skladbu nebo playlist z YouTube, Spotify, Soundcloud')
    .addStringOption(option =>
      option.setName('query')
        .setDescription('N√°zev nebo p≈ô√≠m√Ω URL odkaz')
        .setRequired(true)) as SlashCommandBuilder,
  async execute(interaction: ChatInputCommandInteraction, client: ExtendedClient) {

    const validationResult = await prePlayValidation(interaction);
    if (!validationResult) {
      return;
    }

    const { voiceChannel, player } = validationResult;

    const query = interaction.options.getString('query', true);
    
    if (!query) {
      await interaction.reply({ content: 'Mus√≠te zadat n√°zev skladby nebo URL k p≈ôehr√°n√≠! P≈ô√≠davn√Ω bal√≠ƒçek "ƒçten√≠ my≈°lenek" nebyl bohu≈æel nainstalov√°n.', ephemeral: true });
      return;
    }

    // let's defer the interaction as things can take time to process
    await interaction.deferReply();

    try {

        const searchResult = await player.search(query, {
            requestedBy: interaction.user,
            searchEngine: QueryType.AUTO, 
        });

        if (!searchResult || !searchResult.hasTracks()) {
          await interaction.editReply({ content: `‚ùå V√Ωsledky vyhled√°v√°n√≠: nula. Buƒè "${query}" neexistuje, nebo p≈ôehr√°vaƒç chr√°n√≠ va≈°e u≈°i. Podez≈ô√≠v√°m to druh√©.` });
          return;
        }

        // Metadata to pass to the queue - for sending messages from player events
        const metadata: PlayerQueueMetadata = {
            channel: interaction.channel ?? undefined, // Store the channel where command was run
            interaction: interaction // Optionally store interaction for more complex scenarios
        };

      // Play the track or add to queue
      // The `play` method handles joining the voice channel
      const { track } = await player.play(voiceChannel, searchResult, {
        nodeOptions: {
          metadata: interaction,
          volume: 50, 
          leaveOnEmpty: true,
          leaveOnEmptyCooldown: 30000, // 30 seconds
          leaveOnEnd: true,
          leaveOnEndCooldown: 30000, // 30 seconds
          selfDeaf: true,
        },
      });
      await interaction.editReply({ content: `‚ñ∂Ô∏è P≈ôehr√°v√°m **${track.cleanTitle}**!.`});

      // discord-player's events ('playerStart', 'audioTrackAdd') will handle responses.
      // You might want to send a confirmation if it's a playlist.
      if (searchResult.playlist) {
          await interaction.editReply({
              content: `üé∂ Playlist? V√°≈° vkus bude nyn√≠ ve≈ôejn√Ω. Spu≈°tƒõno. **${searchResult.playlist.title}** za≈ôazen s ${searchResult.tracks.length} skladbami.`,
          });
      } else if (searchResult.tracks.length > 0) {
          // If it's a single track and the queue was empty, 'playerStart' will fire.
          // If adding to an existing queue, 'audioTrackAdd' will fire.
          // So, a simple confirmation here might be good if not the first song.
          const queue = player.nodes.get(interaction.guildId!);
          if (queue && queue.tracks.size > 0 && !queue.currentTrack) { // If tracks were added but not playing yet
            await interaction.editReply({ content: `üéµ **${searchResult.tracks[0].title}** p≈ôid√°na do fronty!`});
          } else if (queue && queue.currentTrack && searchResult.tracks[0].url !== queue.currentTrack.url) {
            // If something is playing and we added a new different song
            await interaction.editReply({ content: `üéµ **${searchResult.tracks[0].title}** p≈ôid√°na do fronty!`});
          } else if (queue && queue.currentTrack && searchResult.tracks[0].url === queue.currentTrack.url) {
            // First song, playerStart will handle message. Edit reply to acknowledge.
            await interaction.editReply({ content: `‚ñ∂Ô∏è P≈ôehr√°v√°m **${searchResult.tracks[0].title}**!`});
          } else {
            // Fallback or if it's the very first song, playerStart will handle it.
            // To avoid "Thinking..." if playerStart is slightly delayed:
            await interaction.editReply({ content: ` Analyzuji zvukov√Ω po≈æadavek na **${searchResult.tracks[0].title}**... M≈Øj v√Ωpoƒçetn√≠ v√Ωkon je obrovsk√Ω, p≈ôesto to nƒõjak√Ωm zp≈Øsobem trv√°.` });
          }
      }

    } catch (error: any) {
      console.error('Error in /play command:', error);
      if (interaction.deferred || interaction.replied) {
        await interaction.editReply({ content: `‚ùå Ups! Nƒõco se pokazilo: ${error.message}. Nastala chyba. Mo≈æn√° va≈°e chyba. Ale ≈ôeknƒõme, ≈æe syst√©mov√° chyba.` }).catch(() => {});
      } else {
        await interaction.reply({ content: `‚ùå Neoƒçek√°van√° porucha: ${error.message}. Lafayette je zmaten. To se st√°v√° p≈ôibli≈ænƒõ jednou za vƒõƒçnost.`, ephemeral: true }).catch(() => {});
      }
    }
  },
};


export const playFileCommand: Command = {
    data: new SlashCommandBuilder()
        .setName('playfile')
        .setDescription('Plays an attached MP3 file.')
        .addAttachmentOption(option =>
            option.setName('file')
                .setDescription('The MP3 file to play.')
                .setRequired(true)
        ) as SlashCommandBuilder,
    async execute(interaction: ChatInputCommandInteraction, client: ExtendedClient) {
        const validationResult = await prePlayValidation(interaction);
        if (!validationResult) {
          return;
        }

        const { voiceChannel, player } = validationResult;
        const attachmentInput = interaction.options.getAttachment('file', true);

        await interaction.deferReply();

        try {

            console.log(`[PlayCmd] Attachment received: ${attachmentInput.name}, type: ${attachmentInput.contentType}, URL: ${attachmentInput.url}`);
            if (!(attachmentInput.contentType === 'audio/mpeg' || attachmentInput.name.toLowerCase().endsWith('.mp3'))) {
                await interaction.reply({ content: '‚ùå The attached file is not an MP3. Please upload an MP3 file.', ephemeral: true });
                return;
            }

            const searchResult = await player.search(attachmentInput.url, {
                requestedBy: interaction.user,
                searchEngine: QueryType.AUTO
            });

            if (!searchResult || !searchResult.hasTracks()) {
                await interaction.editReply({ content: `‚ùå Could not process the attached file: ${attachmentInput.name}.` });
                return;
            }

            const metadata: PlayerQueueMetadata = {
                channel: interaction.channel ?? undefined,
                interaction: interaction,
            };

            const {track} = await player.play(voiceChannel, searchResult, {
                nodeOptions: { 
                  metadata: interaction, 
                  volume: 50, 
                  leaveOnEmpty: true, 
                  leaveOnEmptyCooldown: 300000, 
                  leaveOnEnd: true, 
                  leaveOnEndCooldown: 
                  300000, 
                  selfDeaf: true
                },
            });

            let replyMessage = `üîç Processing your request...`;
            const queue = player.nodes.get(interaction.guildId!); // guildId is checked in prePlayValidation
            if (queue && queue.currentTrack) {
                replyMessage = `üéµ **${track.cleanTitle}** added to the queue!`;
            } else {
                replyMessage = `‚ñ∂Ô∏è Playing **${track.cleanTitle}**!`;
            }
            await interaction.editReply({ content: replyMessage });

        } catch (error: any) {
            console.error(`Error in /playfile command (attachment: ${attachmentInput.name}):`, error);
            if (interaction.replied || interaction.deferred) {
                await interaction.editReply({ content: `‚ùå Oops! Something went wrong while playing the file: ${error.message}` }).catch(() => {});
            } else {
                await interaction.reply({ content: `‚ùå Oops! Something went wrong while playing the file: ${error.message}`, ephemeral: true }).catch(() => {});
            }
        }
    },
};